# 分享

> 浏览器内核主要包括以下三个技术分支：Rendering Engine、 JavaScript engine，以及其他。

本文大致脉络：现阶段遇到的问题->微前端的解决方案->微前端的理论支持->遇到的问题。

### 前言

一般面试喜欢问，从输入一段url到页面展示，这个过程发生了什么。这是个很经典的面试问题，细说说个三天三夜都说不完，从中可以看出一个前端工程师对网络工程、浏览器、前端工程等各个角度的理解，还有个人方向的深入程度。我也抛出一个问题，作为本文的核心内容。

**一个前端项目，从开发到用户使用，这个过程是怎么样的？**

前提：默认有`pageA`组件跟`pageB`组件，项目支持es module，实现按需加载。

- 开始build之后，经由babel、webpack或者其他编译器，不管你写的文件是.vue还是.jsx还是.tsx，甚至wxml、wxss，总之一顿操作，把你的整个项目编译成三个包，html\css\js。

  *因为是单页应用，所以最终只有一个html。js因为要code-splite，在路由变化的时候加载不同资源，会分别打包成chunk~pageA.js、chunk~pageB.js，还有一些乱七八糟的公共组件，比如后台项目常见的layout，loading之类，以及公共依赖vendor.js如vue、react或多次使用的工具函数等。

- 随后这些经过编译压缩后的文件，被部署到服务器上，当用户访问指向该项目的url时，通常会配为index.html，浏览器开始根据html文件的内容开始加载资源，html里会引用入口js。

- 参考如下：一个由umi打包出来的react项目：

  ```
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8" />
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
      />
      <link rel="stylesheet" href="/umi.2547d886.css" />
      <script>
        window.routerBase = "/";
      </script>
      <script>
        //! umi version: 3.2.17
      </script>
      <script src="//res.wx.qq.com/open/js/jweixin-1.2.0.js"></script>
    </head>
    <body>
      <div id="root"></div>
  	// 引入入口js，以及第三方包的js
      <script src="/vendors.29f65054.async.js"></script>
      <script src="/umi.97120b56.js"></script>
    </body>
  </html>
  ```

  自始至终，SPA项目都在一个html里运行，不需要开启新窗口，可以配置异步加载不同“页面”，说是页面，如果了解最开始的vue-router的#意义所在，就会明白，这不是严格意义上的页面切换，只不过是不同的js模块，通过操作dom来完成页面切换的效果。

- 浏览器会根据这个html+CSS+JS的组合，分别启动一个js引擎负责处理js逻辑，以及webcore

- 浏览器

- 大致上，最为基础的spa前端架构就展示完成了。以开发为起点，回归到用户使用。

  用户用的开心，你写得也开心，但是，当你越来越猛，每天能写三千个页面，日产10000000行代码，应用越来越大，但因为有异步加载，用户体验还是一样的，很快，再加上首屏ssr，对用户体验没有任何影响。但背后的痛苦是：几千个page换来的编译时间会越来越久，一个小小的bug都可能导致编译失败，人直接崩溃，这时候，你会要求，~~公司换个五百核的服务器跟开发电脑~~，想办法优化。怎么优化呢，这是巨石应用的由来，也是我们要解决的问题。

  ![image-20201104185522856](C:\Users\simple\AppData\Roaming\Typora\typora-user-images\image-20201104185522856.png)

### 解决方案

如果仔细看上一段的总结，会发现，其实现在面临的问题，并不是用户体验的问题，实际上这是一个面向开发者的问题：当拆解打包一个巨石应用的时候，耗时太久，出现错误的时候难以纠正。

当我们审视上面的流程图时，很容易想到解决办法，做个<u>*入口页面*</u>，然后把<u>*其他页面*</u>单独打包。在适当的时候异步引入这些包，就可以解决问题了。解决这个问题的方法，我们可以把它叫做微前端。这种概念其实并不清晰，因为这个流程图很长，我们可以在不同的阶段进行一些“微前端”的操作。但这些方式都有各自的缺陷以及优点。

首先我们明确一点，要做的是什么：有个父应用，以及若干个子应用，但每个子应用，是可以独立开发的，即，脱离父应用，也可以跑起来。

如果仅仅是这样，单说这个，熟悉组件库开发的有话要说了，其实前端组件库，就很符合这个特性，开发环境webpack指向demo的html入口，符合独立运行的需求，打包发布之后在父应用里跑起来更不用说了。事实上，我看到了掘金一些关于微前端的应用思路，很多就跟组件库差不多，采用挂在父应用上面的方法。**但是**，这个方案有个致命缺陷，应用之间的js作用域没有完全隔离，css更不用说，如果有若干个子应用，彼此有一些重复的类名，样式极易产生污染。

因此，还需要补充一下，应用之间js作用域相互独立，css样式隔离。

OK，`<iframe>`标签搞定，如果不考虑通信，迷惑的url、window对象、本地缓存等问题，iframe确实是个很完美的解决办法，完全隔离的js，甚至chrome为其单独开辟了一个js进程以及渲染进程，保证100%的隔离环境。而且代码之间基本上能保证100%的解耦。

但是，如果把iframe也定义为微前端，我把浏览器看作父应用，每个标签看作一个子应用，那岂不是天然就有微前端了？确实有人是这么认为的，也这么做了，比如小程序，就是这样的，以微信小程序为例，微信app可以同时可以打开多个不同小程序，为彼此之间分配不同进程用以渲染跟执行脚本。只不过为了安全起见，屏蔽接管了部分样式属性，禁用了一些语法。

> 小程序的原理大致是将写好的wxml+wxss+wxs用自己的语法解析器解析，将一些语法转译成native的东西，一部分东西转译成js+html+css，大致上还是可以理解成普通的前端页面，但为了接入native做了一些优化的工作，类似rn。

边界开始变得模糊了，所以，在主流的微前端框架中，一般都会事先声明，自己是SPA







首先讲一下微前端的概念，最近微前端征文，很少看到有讲到概念层面的东西，大多数是一些前端框架的实践，demo之类，感觉对小白不是很友好，让人看得一头雾水。有的人说小程序是微前端，有的人说qiankun是微前端，那到底微前端是啥？是一种概念？还是一种架构？一种框架？正好本人在公司有做类似的实践，谈一谈本人对微前端的理解，献丑做个抛砖引玉。

广义的微前端：

刚刚说完狭义的微前端，很明显有的人会觉得不对劲，发出灵魂拷问疑问：~~就这？~~那iframe算不算微前端？如果把iframe也算在微前端里，小程序算不算？公众号算不算？先回答，当然算，且听我慢慢道来。

要理解广义上的微前端，就得先知道什么是前端，正如想做一盘牛排，我们先得学会如何接生小牛崽一样。

这里的前端，指的是web前端，简单点讲，前端工程师把HTML、JavaScript、CSS这“三驾马车”作为输入，经过WebKit的处理，就输出成了我们能看到以及操作的Web页面。WebKit是一个页面渲染以及逻辑处理引擎，下面是偷的两幅webkit架构图（《[认识V8引擎](https://zhuanlan.zhihu.com/p/27628685)》，《[深入理解JSCore](https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html)》），很直接明确，有眼睛就能看懂，在此不赘述。

![preview](https://pic4.zhimg.com/v2-959135939fe2cbc2d9a437ef81dff328_r.jpg)

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/c718ac49.png)

理论上来说，只要有渲染引擎就可以完整地把js+html+css组成的页面呈现到页面上，渲染引擎有Tridend(IE)、Gecko(FF)、WebKit(Safari,Chrome,Andriod浏览器)等。WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。

想想我们熟悉的chrome浏览器，标签页之间的页面是不是隔离的，支持页面的代码是不是都是html+css+js。其实我们看看chrome的架构或者打开任务管理器就会知道，每个浏览器窗口都有1个浏览器主进程**、**1个GPU进程**、**1个网络进程、和多个插件进程、**多个渲染进程对应不同标签页（不完全是，iframe在chrome中也会单独起进程）**。每个标签页中的context（比如vuex、redux中你设定好的全局变量，chrome会将其存在内存中，由进程管理）都是完全隔离的，但又要与父容器有通信，可控（比如历史记录、钥匙串之类）。是不是很熟悉，跟微前端很像，所以我把这种模式的微前端称之为广义上的微前端。

引申解释：为什么小程序也算微前端，因为小程序是跑在native的h5容器中的，通过自定义的dsl（WXML+WXS的组合）书写-即渲染引擎不同，结果同样是 HTML/CSS/JS 显示在 webview 上。

## 总结

广义的微前端定义：

- 渲染引擎一致即容器内底层支持一致。
- 可以支持运行多个子应用，为每个应用起一个单独进程，独立context。

狭义微前端的定义：

- web应用中的一个js模块，可以是另一个web应用，也可以是一个组件，一个函数。

殊途同归，广义上的微前端大多是为了支持

> 对于这块，[bang 的博客](https://link.zhihu.com/?target=http%3A//blog.cnbang.net/tech/3486/) 从需求分析技术方案分析的很不错，在小程序出来之前，各大平台是怎么解决开放问题的呢，大都通过纯 H5 应用来实现开放，平台提供 H5 容器，并通过 jsapi 提供 Native 接口，第三方开发者开发 H5 应用并调用平台提供的接口，然后将 H5 应用嵌入到平台中，也可以使用平台提供的各方面能力。 这种方案有以下几个主要问题： *平台对纯 H5 应用缺乏管控，开发者几乎可以随意改变应用，平台对这块的管控非常困难，作为平台如果没有管控能力是很危险的* 纯 H5 应用体验太差，无论是启动速度还是页面渲染速度都与 Native 相去甚远

基于这点微前端就是容器化的概念，类似k8s，由父容器与子容器组成，父容器管理子容器，父子可通信（数据通信，样式通信=>比如modal，但偶尔也会需要样式隔离，比如webIDE，此时就需要iframe，据说web-component也能实现这种需求）。在不同环境，保证父容器一致，子容器中跑同一套代码就是可以实现的。

狭义的微前端：

>  In the context of single-spa, a microfrontend is often an in-browser JavaScript module 
>
> 微前端是浏览器内的javascript模块。  -single-spa官网定义

这种微前端，single-spa将其分为了三种：Application（应用程序）、Parcel（沙箱）、Utility（公共模块）



|          | Application（应用程序） | Parcel（包） | Utility      |
| -------- | ----------------------- | ------------ | ------------ |
| 路由     | 有多个路由              | 无           | 无           |
| API      | 声明式API               | 必要API      | 提供接口     |
| 渲染UI   | 有                      | 有           | 不直接渲染UI |
| 生命周期 | single-spa管理生命周期  |              |              |
| 何时使用 |                         |              |              |



### 

参考资料：

- 《认识 V8 引擎》：https://zhuanlan.zhihu.com/p/27628685
- 待完工，认知不准确


